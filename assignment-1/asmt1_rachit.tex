\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{parskip}
\usepackage{hyperref}

\usepackage[margin=2.2cm]{geometry}

\title{Theory Assignment-1: ADA Winter-2024}
\author{Rachit Arora (2022384) \and Mahi Mann (2022272)}

\date{}
\begin{document}

\maketitle

\section{Assumptions}

\begin{enumerate}
    \item $k$ ranges from $1$ to $3n$.
    \item $A \cup B \cup C$ is the concatenation of the 3 arrays $A$, $B$ and $C$. Formally, if $A = \{ a_1 , a_2 , \cdots a_n \}$, $B = \{ b_1 , b_2 , \cdots b_n \}$ and $C = \{ c_1 , c_2 \cdots c_n \}$; $A \cup B \cup C = \{ a_1 , a_2 , \cdots a_n , b_1 , b_2 , \cdots b_n , c_1 , c_2 , \cdots c_n\}$.   
    \item Array indices are from $1$ to $n$.
\end{enumerate}

\section{Preprocessing}
% Your preprocessing steps go here

None required.

\section{Algorithm Description}

We start with the arrays $A$, $B$ and $C$ as the main problem.

The algorithm is recursive. Consider the current subarrays to be $S_0$, $S_1$ and $S_3$, and the current element to be found as the $k\textsuperscript{th}$ smallest.

Define $mid(S_i) = \lfloor \frac{n_i}{2} \rfloor$ where $n_i$ is the size of the array $S_i$, where $i = 0,1,2$.  

We have two cases, $\sum_{i=0}^{2} mid(S_i) \leq k$ and $\sum_{i=0}^{2} mid(S_i) > k$. 

\begin{enumerate}

\item Let's consider the first case, $\sum_{i=0}^{2} mid(S_i) \leq k$.

    Without loss of generality, let $S_0[mid(S_0)]$ be the \textbf{minimum} of all $S_i[mid(S_i)]$ for $i=0,1,2$.

        Then, all elements of $S_0[1, \cdots, mid(S_0) - 1]$ can be written as the $j\textsuperscript{th}$ smallest in $S_0 \cup S_1 \cup S_2$ where $j < k$ (refer to \hyperlink{section.7}{Proof of Correctness}).

        So, our required element may not be in $S_0[1, \cdots, mid(S_0) - 1]$ because they can be at most the $(k-1)\textsuperscript{th}$ smallest, but it is definitely elsewhere in the remaining subarray and 2 arrays.

        So, we recursively find the $(k - mid(S_0) + 1)\textsuperscript{th}$ smallest element in $S_0[mid(S_0), \cdots, n_0] \cup S_1 \cup S_2$.

\item Now for the latter case, $\sum_{i=0}^{2} mid(S_i) > k$.

    Without loss of generality, let $S_0[mid(S_0)]$ be the \textbf{maximum} of all $S_i[mid(S_i)]$ for $i=0,1,2$.

        Then, all elements of $S_0[mid(S_0), \cdots, n_0]$ can be written as the $j\textsuperscript{th}$ smallest in $S_0 \cup S_1 \cup S_2$ where $j > k$ (refer to \hyperlink{section.7}{Proof of Correctness}).

        So, our required element may not be in $S_0[mid(S_0), \cdots, n_0]$ because they can be at least the $(k+1)\textsuperscript{th}$ smallest, but it is definitely elsewhere in the remaining subarray and 2 arrays.

        So, we recursively find the $k\textsuperscript{th}$ smallest element in $S_0[1, \cdots, mid(S_0) - 1] \cup S_1 \cup S_2$.

\end{enumerate}

The base case for the recursion is simple. If the arrays $S_0$, $S_1$ and $S_2$ all have a single element, then the elements smaller than them will be $k-1$ in total, so we return the minimum of these 3 elements.

Furthermore, for completeness, if at any point of the algorithm an array cannot be divided further, we only recurse further on arrays which can.


\section{Recurrence Relation}
% Provide the recursive relation of your algorithm

Let $p = n_1n_2n_3$ be the current product of the sizes of A, B and C; $n_1$, $n_2$ and $n_3$ respectively. Since the size of one of the arrays in the next subproblem will be approximately halved, size of the next subproblem $p' = \frac{p}{2}$. The only serial (non-recursive) operation is comparing two elements in $A \cup B \cup C$, which can be done in $O(1)$ as defined, so the serial time taken is less than equal to $c_0$ for some positive real constant $c_0$. 

Therefore, we have:

\begin{align*}
    T(p) = T(p') + c_0 \\
    T(p) = T(\frac{p}{2}) + c_0
\end{align*}

\section{Complexity Analysis}
% Analyze the time and space complexity of your algorithm

The above recurrence relation can be expressed as 

\begin{align*}
    T(p) = aT(\frac{p}{b}) + k_0p^c
\end{align*}

where $a = 1, b = 2, c = 0$.

By Master's theorem, since $0 = \log_2{1}$ and thus $c = \log_b{a}$, 

\begin{align*}
    T(p) = O(\log p)
\end{align*}

Since $p = n_1n_2n_3$, $\log p = \log n_1 + \log n_2 + \log n_3 = 3 \log n$.

\textbf{Therefore, the overall problem with 3 arrays of size $n$ can be solved in $O(3 \log n) = O(\log n)$ time.} 

\section{Pseudocode}

\begin{algorithm}[H]
\caption{KthSmallest}
\begin{algorithmic}[1]

\Function {KthSmallest}{A, B, C, n, k} 
    \\ \phantom a \phantom .
    \Return FindKth(A, B, C, 1, n, 1, n, 1, n, k)
\EndFunction

\\

\Function {FindKth}{X, Y, Z, $x_0$, $x_1$, $y_0$, $y_1$, $z_0$, $z_1$, $k$}

    \\

    \If {$x_0 = x_1$ and $y_0 = y_1$ and $z_0 = z_1$}
        \If {$k = 1$}
        \Return min( X[$x_0$], Y[$y_0$], Z[$z_0$] )
        \EndIf
        \If {$k = 3$}
        \Return max( X[$x_0$], Y[$y_0$], Z[$z_0$] )
        \EndIf

        \\
        \phantom a \phantom a \phantom . \phantom .
        \Return  X[$x_0$] + Y[$y_0$] + Z[$z_0$] - ( min( X[$x_0$], Y[$y_0$], Z[$z_0$] ) + max( X[$x_0$], Y[$y_0$], Z[$z_0$] ) )
    \EndIf

    \\
    \State $M \gets (-\infty)$
    \State $m \gets \infty$

    \If {$x_1 > x_0$}
        \State $M \gets \max(M, \text{X[ \begin{math} \lfloor \frac{x_0 + x_1}{2} \rfloor \end{math} ]})$
        \State $m \gets \min(m, \text{X[ \begin{math} \lfloor \frac{x_0 + x_1}{2} \rfloor \end{math} ]})$
    \EndIf

    \If {$y_1 > y_0$}
        \State $M \gets \max(M, \text{Y[ \begin{math} \lfloor \frac{y_0 + y_1}{2} \rfloor \end{math} ]})$
        \State $m \gets \min(m, \text{Y[ \begin{math} \lfloor \frac{y_0 + y_1}{2} \rfloor \end{math} ]})$
    \EndIf

    \If {$z_1 > z_0$}
        \State $M \gets \max(M, \text{Z[ \begin{math} \lfloor \frac{z_0 + z_1}{2} \rfloor \end{math} ]})$
        \State $m \gets \min(m, \text{Z[ \begin{math} \lfloor \frac{z_0 + z_1}{2} \rfloor \end{math} ]})$
    \EndIf
    
    \\
    \If {$\lfloor \frac{x_0 + x_1}{2} \rfloor + \lfloor \frac{y_0 + y_1}{2} \rfloor + \lfloor \frac{z_0 + z_1}{2} \rfloor \leq$ k}
    \\

        \If {$x_1 > x_0$ and $m = X[ \lfloor \frac{x_0 + x_1}{2} \rfloor ]$}
        \\ \phantom a \phantom a \phantom a \phantom a \phantom a 
        \Return FindKth(X, Y, Z, $\lfloor \frac{x_0 + x_1}{2} \rfloor$, $x_1$, $y_0$, $y_1$, $z_0$, $z_1$, $k + 1 - \lfloor \frac{x_0 + x_1}{2} \rfloor  $)
        \EndIf
        \If {$y_1 > y_0$ and $m = Y[ \lfloor \frac{y_0 + y_1}{2} \rfloor ]$}
        \\ \phantom a \phantom a \phantom a \phantom a \phantom a 
        \Return FindKth(X, Y, Z, $x_0$, $x_1$, $\lfloor \frac{y_0 + y_1}{2} \rfloor$, $y_1$, $z_0$, $z_1$, $k + 1 - \lfloor \frac{y_0 + y_1}{2} \rfloor  $)
        \EndIf
        \\ \phantom a \phantom a \phantom a \phantom . 
        \Return FindKth(X, Y, Z, $x_0$, $x_1$, $y_0$, $y_1$, $\lfloor \frac{z_0 + z_1}{2} \rfloor$, $z_1$, $k + 1 - \lfloor \frac{z_0 + z_1}{2} \rfloor  $)
    \Else
    \\

        \If {$x_1 > x_0$ and $M = X[ \lfloor \frac{x_0 + x_1}{2} \rfloor ]$}
        \\ \phantom a \phantom a \phantom a \phantom a \phantom a 
        \Return FindKth(X, Y, Z, $x_0$, $\lfloor \frac{x_0 + x_1}{2} \rfloor - 1$, $y_0$, $y_1$, $z_0$, $z_1$, $k + 1 - \lfloor \frac{x_0 + x_1}{2} \rfloor  $)
        \EndIf
        \If {$y_1 > y_0$ and $M = Y[ \lfloor \frac{y_0 + y_1}{2} \rfloor ]$}
        \\ \phantom a \phantom a \phantom a \phantom a \phantom a 
        \Return FindKth(X, Y, Z, $x_0$, $x_1$, $\lfloor \frac{y_0 + y_1}{2} \rfloor$, $y_1$, $z_0$, $z_1$, $k + 1 - \lfloor \frac{y_0 + y_1}{2} \rfloor  $)
        \EndIf
        \\ \phantom a \phantom a \phantom a \phantom . 
        \Return FindKth(X, Y, Z, $x_0$, $x_1$, $y_0$, $y_1$, $\lfloor \frac{z_0 + z_1}{2} \rfloor$, $z_1$, $k + 1 - \lfloor \frac{z_0 + z_1}{2} \rfloor  $)
    \EndIf

\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Proof of Correctness}
% Provide the proof of correctness for your algorithm

The explanation of how the algorithm works is provided in the 

\end{document}
