\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{parskip}
\usepackage{hyperref}

\usepackage[margin=2.2cm]{geometry}

\title{Theory Assignment-1: ADA Winter-2024}
\author{Rachit Arora (2022384) \and Mahi Mann (2022272)}

\date{}
\begin{document}

\maketitle

\section{Assumptions}

\begin{enumerate}
    \item $k$ ranges from $1$ to $3n$.
    \item $A \cup B \cup C$ is the concatenation of the 3 arrays $A$, $B$ and $C$. Formally, if $A = \{ a_1 , a_2 , \cdots a_n \}$, $B = \{ b_1 , b_2 , \cdots b_n \}$ and $C = \{ c_1 , c_2 \cdots c_n \}$; $A \cup B \cup C = \{ a_1 , a_2 , \cdots a_n , b_1 , b_2 , \cdots b_n , c_1 , c_2 , \cdots c_n\}$.   
    \item Array indices are from $1$ to $n$.
\end{enumerate}

\section{Preprocessing}
% Your preprocessing steps go here

None required.

\section{Algorithm Description}

We start with the arrays $A$, $B$ and $C$ as the main problem.

The algorithm is recursive. Consider the current subarrays to be $S_0$, $S_1$ and $S_3$, and the current element to be found as the $k\textsuperscript{th}$ smallest.

Define $mid(S_i) = \lfloor \frac{n_i}{2} \rfloor$ where $n_i$ is the size of the array $S_i$, where $i = 0,1,2$.  

We have two cases, $\sum_{i=0}^{2} mid(S_i) \leq k$ and $\sum_{i=0}^{2} mid(S_i) > k$. 

\begin{enumerate}

\item Let's consider the first case, $\sum_{i=0}^{2} mid(S_i) \leq k$.

    Without loss of generality, let $S_0[mid(S_0)]$ be the \textbf{minimum} of all $S_i[mid(S_i)]$ for $i=0,1,2$.

        Then, all elements of $S_0[1, \cdots, mid(S_0) - 1]$ can be written as the $j\textsuperscript{th}$ smallest in $S_0 \cup S_1 \cup S_2$ where $j < k$ (refer to \hyperlink{section.7}{Proof of Correctness}).

        So, our required element may not be in $S_0[1, \cdots, mid(S_0) - 1]$ because they can be at most the $(k-1)\textsuperscript{th}$ smallest, but it is definitely elsewhere in the remaining subarray and 2 arrays.

        So, we recursively find the $(k - mid(S_0) + 1)\textsuperscript{th}$ smallest element in $S_0[mid(S_0), \cdots, n_0] \cup S_1 \cup S_2$.

\item Now for the latter case, $\sum_{i=0}^{2} mid(S_i) > k$.

    Without loss of generality, let $S_0[mid(S_0)]$ be the \textbf{maximum} of all $S_i[mid(S_i)]$ for $i=0,1,2$.

        Then, all elements of $S_0[mid(S_0), \cdots, n_0]$ can be written as the $j\textsuperscript{th}$ smallest in $S_0 \cup S_1 \cup S_2$ where $j > k$ (refer to \hyperlink{section.7}{Proof of Correctness}).

        So, our required element may not be in $S_0[mid(S_0), \cdots, n_0]$ because they can be at least the $(k+1)\textsuperscript{th}$ smallest, but it is definitely elsewhere in the remaining subarray and 2 arrays.

        So, we recursively find the $k\textsuperscript{th}$ smallest element in $S_0[1, \cdots, mid(S_0) - 1] \cup S_1 \cup S_2$.

\end{enumerate}

The base case for the recursion is simple. If the arrays $S_0$, $S_1$ and $S_2$ all have a single element, then the elements smaller than them will be $k-1$ in total, so we return the minimum of these 3 elements.

Furthermore, for completeness, if at any point of the algorithm an array cannot be divided further, we only recurse further on arrays which can.


\section{Recurrence Relation}
% Provide the recursive relation of your algorithm

Let $p = n_1n_2n_3$ be the current product of the sizes of A, B and C; $n_1$, $n_2$ and $n_3$ respectively. Since the size of one of the arrays in the next subproblem will be approximately halved, size of the next subproblem $p' = \frac{p}{2}$. The only serial (non-recursive) operation is comparing two elements in $A \cup B \cup C$, which can be done in $O(n)$ as defined, so the serial time taken is less than equal to $c_0$ for some positive real constant $c_0$. 

Therefore, we have:

\begin{align*}
    T(p) = T(p') + c_0 \\
    T(p) = T(\frac{p}{2}) + c_0
\end{align*}

\section{Complexity Analysis}
% Analyze the time and space complexity of your algorithm

The above recurrence relation can be expressed as 

\begin{align*}
    T(p) = aT(\frac{p}{b}) + k_0p^c
\end{align*}

where $a = 1, b = 2, c = 0$.

By Master's theorem, since $0 = \log_2{1}$ and thus $c = \log_b{a}$, 

\begin{align*}
    T(p) = O(\log p)
\end{align*}

Since $p = n_1n_2n_3$, $\log p = \log n_1 + \log n_2 + \log n_3 = 3 \log n$.

\textbf{Therefore, the overall problem with 3 arrays of size $n$ can be solved in $O(3 \log n) = O(\log n)$ time.} 

\section{Pseudocode}

\begin{algorithm}[H]
\caption{KthSmallest}
\begin{algorithmic}[1]

\Function {KthSmallest}{params}
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Proof of Correctness}
% Provide the proof of correctness for your algorithm


\end{document}
